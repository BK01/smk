<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>BETA - CVRP - Translink</title>
        
        <!-- SMK BOOTSTRAP - - - - - - - -->
        <script src="../../smk.js"></script>
        <!-- - - - - - - - - - - - - - - -->

        <style>
            @page {
                margin: 1em;
                size: letter portrait;
                /* background-color: yellow; */
            }

            body {
                font-family: Helvetica,Arial,sans-serif;
            }

            @media print {
                /* margin: 1em; */
                /* size: portrait; */
                body {
                    background-color: yellow;
                }
            }

            header {
                /* position: absolute;
                top: 0;
                left: 0;
                right: 0; */
                height: 70px;

                border-bottom:      2px solid #fcba19;
                background-color: #036;

                display:            flex;
                justify-content:    flex-start;
                align-items:        center;
            }

            .build-info {
                display: flex;
                flex-direction: column;
                align-items: flex-end;

                flex-grow: 1;
                font-size: 12px;
                color: #ccc;
                padding-right: 10px;
            }

            img.siteLogo {
                margin-left:    10px;
                margin-bottom:  10px;
                height: 40px;
            }

            .header-title {
                color:          white;
                margin-left:    20px;

                display:        flex;
                flex-direction: column;
                justify-content:center;
                align-items:    flex-start;
                font-size:      18px;
            }

            article {
                /* border: 2px solid black; */
                position: relative;
                height: 10in;
                width: 7.5in;
                margin: auto;

                display: flex;
                flex-direction: column;
                justify-content: space-between;
                page-break-after: always;
            }

            .page {
                display: flex;               
                flex-grow: 1; 
            }

            section {
                display: flex;
                flex-direction: column;
                justify-content: space-between;
            }

            section.left-side {
                flex-basis: 75%;
            }

            section.right-side {
                flex-basis: 25%;
            }

            .smk-map-frame {
                flex: 1 1;
                border: 2px solid black;
                border-radius: 3px;
            }

            .waypoints {
                min-height: 4em;
                /* background-color: orange; */
            }

            .directions {
                /* background-color: yellow; */
                height: 100%;
            }
        </style>

    </head>

    <body>
        <div id="vue-root"></div>

        <template id="template">
            <div id="route-pages">
                <article
                    v-for="page in pages"
                >
                    <header>
                        <!-- <img src="bc-gov-logo-transparent.png"> -->
                        <img src="https://tlweblibs.translink.ca/TransLink-logo-white.svg" alt="TransLink Logo" class="siteLogo">
                        <div class="header-title">Vehicle Route - Commercial Vehicle Route Planner Beta</div>
                        <div class="build-info"></div>
                    </header>
                        
                    <div class="page">
                        <section class="left-side">
                            <div class="waypoints">
                                <div class="waypoint"
                                    v-for="w in waypoints"
                                >{{ 
                                    w.fullAddress 
                                }}</div>
                            </div>

                            <div class="smk-map-frame"
                                v-content="page.map"
                            ></div>
                        </section>
        
                        <section class="right-side">
                            <div class="directions">
                                <div class="direction"
                                    v-for="d in page.directions"
                                >
                                    <span class="instruction">{{ d.instruction }}</span>
                                    <span class="metric"
                                        v-if="d.distance"
                                    >for {{ d.distance }} ({{ d.time }})</span>
                                </div>
                            </div>
                        </section>
                    </div>
                </article>            
            </div>
        </template>
    </body>

    <script>
        function close( p1, p2, min ) { 
            var d0 = p1[0] - p2[0]
            var d1 = p1[1] - p2[1]
            return ( d0 * d0 + d1 * d1 ) <= ( min * min )
        }

        include.option( { baseUrl: ( new URL( '../..', document.location ) ).toString() } )

        include( 'vue', 'vue-config', 'turf' ).then( function () {

            console.log('hi')
        // try {
            var key = location.search.substr( 1 )
            var cfg = JSON.parse( window.sessionStorage.getItem( key ) )

            var dirs = cfg.etc.directions
            delete cfg.etc
            delete cfg.tools
            var mapCfg = JSON.stringify( cfg )

            var spi = 0, pi = 0, prevRoute
            dirs.directions.forEach( function ( d ) {
                if ( !prevRoute ) {
                    prevRoute = d
                    return
                }

                while ( !close( dirs.route[ pi ], d.point, 0.0001 ) ) {
                    pi += 1
                }
                
                prevRoute.route = {
                    start: spi,
                    end: pi
                }

                spi = pi
                prevRoute = d
            } )
            prevRoute.route = {
                start: pi,
                end: pi
            }

            var maxDirs = 10

            var len = dirs.directions.length 
            var pages = Math.round( len / maxDirs ) 
            var perPage = Math.round( len / pages )

            var model = {
                waypoints: dirs.waypoints,
                pages: Array( pages ).fill().map( function () { return { 
                    route: [], 
                    directions: [], 
                    map: {} 
                } } )
            }

            function bearingToDir( b ) {
                if ( b > -45  && b < 45 ) return 'top'
                if ( b > 45   && b < 135 ) return 'right'
                if ( b > -135 && b < -45 ) return 'left'
                return 'bottom'
            }

            model.pages.forEach( function ( p, pi ) {
                p.map.create = function ( el ) {
                    var ls = turf.lineString( p.route )
                    var bb = turf.bbox( ls )
                    var diag = turf.distance( [ bb[0], bb[1] ], [ bb[2], bb[3] ] )
                    var cent = turf.center( turf.bboxPolygon( bb ) )
                    
                    var c = JSON.parse( mapCfg )
                    c.layers.push( {
                        type: 'vector',
                        id: 'route',
                        isVisible: true,
                        dataUrl: 'data:application/json,' + JSON.stringify( turf.lineString( p.route ) ),
                        style: {
                            strokeColor: "green",
                            strokeWidth: 8,
                            strokeOpacity: 0.8,
                            fillOpacity: 0.6,
                            fillColor: "blue"
                        }
                    } )

                    var slots = perPage * 3
                    var pos = []

                    p.directions.forEach( function ( d, i ) {
                        pos.push( { 
                            dir: d,
                            bearing: turf.bearing( cent, d.point ),
                            quant: Math.trunc( ( turf.bearing( cent, d.point ) + 360 - 180 / slots ) * slots / 360 ) % slots,
                            quantBearing: function ( off ) {
                                return this.move( off ) * 360 / slots + 180 / slots
                            },
                            error: function ( off ) {
                                var er = Math.abs( this.quantBearing( off ), this.bearing )
                                if ( er < 180 ) return er
                                return 360 - er 
                            },
                            move: function ( off ) {
                                if ( !off ) return this.quant
                                return ( this.quant + slots + Math.ceil( off / 2 ) * ( 2 * ( off % 2 ) - 1 ) ) % slots 
                            }
                        } )
                    } )

                    pos.sort( function ( a, b ) {
                        return a.bearing - b.bearing
                    } )
                    
                    function smallestErr( off ) {
                        var mini, min = 9999

                        pos.forEach( function ( p, i ) {
                            if ( p.done ) return

                            if ( p.error( off ) > min ) return

                            min = p.error( off )
                            mini = i
                        } )
                        
                        if ( mini == null ) return
                        return pos[ mini ]
                    }

                    var quant = [], offset = 0 

                    Array( p.directions.length ).fill().forEach( function ( xxx, pi ) {

                        var p 
                        while ( p == null ) {
                            p = smallestErr( offset )
                            if ( p && !quant[ p.move( offset ) ] ) break
                            offset += 1 
                        } 

                        p.done = true
                        quant[ p.move( offset ) ] = true
                        // pos.forEach( function ( d, i ) {
                            // if ( pos.done ) return 

                            // var bearing = turf.bearing( cent, d.point )
                            // var b = Math.trunc( ( turf.bearing( cent, d.point ) + 360 ) * slots / 360 ) % slots
                            // while ( pos[ b ] ) {
                                // b = ( b + 1 ) % slots
                            // }
                            // pos[ b ] = true
                            // var edge = turf.rhumbDestination( cent, diag / 2, b * 360 / slots + 180 / slots )
                            var edge = turf.rhumbDestination( cent, diag / 3 * 2, p.quantBearing( offset ) )

                            c.layers.push( {
                                type: 'vector',
                                id: 'edge-' + pi,
                                isVisible: true,
                                dataUrl: 'data:application/json,' + JSON.stringify( turf.lineString( [ p.dir.point, edge.geometry.coordinates ] ) ),
                                style: {
                                    strokeColor: "blue",
                                    strokeWidth: 8,
                                    strokeOpacity: 0.8
                                }
                            } )

                            // c.layers.push( {
                            //     type: 'vector',
                            //     id: 'dir-' + i,
                            //     isVisible: true,
                            //     dataUrl: 'data:application/json,' + JSON.stringify( turf.point( d.point ) ),
                            //     tooltip: {
                            //         title: '#' + ( i + 1 ),
                            //         option: {
                            //             direction: bearingToDir( )
                            //         }
                            //     },
                            //     style: {
                            //         strokeColor: "red",
                            //         strokeWidth: 8,
                            //         strokeOpacity: 0.8
                            //     }
                            // } )
                        } )
        
                    // } )

                    c.viewer.location = {
                        // extent: turf.bbox( turf.buffer( turf.bboxPolygon( bb ), diag * 0.1 ) )
                        extent: turf.bbox( turf.circle( cent, diag  ) )
                    }

                    return SMK.INIT( {
                        'smk-id':           'print-' + pi,
                        'smk-container-sel': el,
                        'smk-config':       [ c, 'hide-tool=all' ]
                    } )
                }

                for ( var d = 0; d < perPage; d += 1 ) {
                    if ( pi * perPage + d >= dirs.directions.length ) break

                    var dr = dirs.directions[ pi * perPage + d ]
                    p.directions.push( dr )

                    for ( var r = dr.route.start; r <= dr.route.end; r += 1 ) {
                        p.route.push( dirs.route[ r ] )
                    } 
                }
            } )

            
            new Vue( {
                el: '#vue-root',
                template: '#template',
                data: model
            } )
        } )
        // SMK.INIT( {
        //     'smk-container-sel': "#smk-map-frame",
        //     'smk-config': "?|hide-tool=all",
        // } ).then( function () {
        //     $( '#build-info' ).empty()
        //         .append( '<div>Version: ' + SMK.BUILD.version +'</div>' )
        //         .append( '<div>Last commit: ' + SMK.BUILD.lastCommit +'</div>' )
        //         .append( '<div>Commit ID: ' + SMK.BUILD.commit +'</div>' )
        //         .append( '<div>Branch: ' + SMK.BUILD.branch +'</div>' )

        //     new Vue( {
        //         el: '#waypoints-mount',
        //         template: '#waypoints-template',
        //         data: SMK.MAP[1].etc.directions
        //     } )

        //     new Vue( {
        //         el: '#directions-mount',
        //         template: '#directions-template',
        //         data: SMK.MAP[1].etc.directions
        //     } )

        // // console.log('window size',$(window).width(),$(window).height());
        //         SMK.MAP[1].$viewer.map.invalidateSize() 
        //         SMK.MAP[1].$viewer.resizeToExtent() 

        // } )

    </script>
</html>
